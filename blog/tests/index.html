<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testy | Piotr Musiał</title><meta name=keywords content="tests"><meta name=description content="Testy to święty gral początkujących programistów. Będąc na stanowisku CTO prowadziłem sporo rekrutacji na stanowiska juniorskie. Najczęściej powtarzaną przez rekrutów pożądaną cechą zespołu było praktykowanie pisania testów.
Przy okazji testów wszyscy wspominali o podejściu TDD (Test Driven Design), a nawet byli w stanie zdefiniować głównego założenie tego podejścia. Niestety ani jeden z nich nie pracował w takim podejściu, a zdecydowana większość z nich nigdy nawet nie pisała testów. Wszyscy narzekali, że w projektach, z którymi obecnie pracują testów nie ma i podawali to jako główną przyczynę problemów z aplikacją."><meta name=author content="Piotr Musiał"><link rel=canonical href=https://piotrmus.github.io/blog/tests/><link href=/assets/css/stylesheet.min.0e4a1b49e740c28140e9ee4945aab2f86cb0a7bfbf5a5d612d0cb5df7d6141f4.css integrity="sha256-DkobSedAwoFA6e5JRaqy+Gywp7+/Wl1hLQy1331hQfQ=" rel="preload stylesheet" as=style><link rel=icon href=https://piotrmus.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://piotrmus.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://piotrmus.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://piotrmus.github.io/apple-touch-icon.png><link rel=mask-icon href=https://piotrmus.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','G-7ZE3XYWHQ5','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Testy"><meta property="og:description" content="Testy to święty gral początkujących programistów. Będąc na stanowisku CTO prowadziłem sporo rekrutacji na stanowiska juniorskie. Najczęściej powtarzaną przez rekrutów pożądaną cechą zespołu było praktykowanie pisania testów.
Przy okazji testów wszyscy wspominali o podejściu TDD (Test Driven Design), a nawet byli w stanie zdefiniować głównego założenie tego podejścia. Niestety ani jeden z nich nie pracował w takim podejściu, a zdecydowana większość z nich nigdy nawet nie pisała testów. Wszyscy narzekali, że w projektach, z którymi obecnie pracują testów nie ma i podawali to jako główną przyczynę problemów z aplikacją."><meta property="og:type" content="article"><meta property="og:url" content="https://piotrmus.github.io/blog/tests/"><meta property="article:published_time" content="2021-02-22T20:09:07+01:00"><meta property="article:modified_time" content="2021-02-22T20:09:07+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Testy"><meta name=twitter:description content="Testy to święty gral początkujących programistów. Będąc na stanowisku CTO prowadziłem sporo rekrutacji na stanowiska juniorskie. Najczęściej powtarzaną przez rekrutów pożądaną cechą zespołu było praktykowanie pisania testów.
Przy okazji testów wszyscy wspominali o podejściu TDD (Test Driven Design), a nawet byli w stanie zdefiniować głównego założenie tego podejścia. Niestety ani jeden z nich nie pracował w takim podejściu, a zdecydowana większość z nich nigdy nawet nie pisała testów. Wszyscy narzekali, że w projektach, z którymi obecnie pracują testów nie ma i podawali to jako główną przyczynę problemów z aplikacją."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://piotrmus.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Testy","item":"https://piotrmus.github.io/blog/tests/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Testy","name":"Testy","description":"Testy to święty gral początkujących programistów. Będąc na stanowisku CTO prowadziłem sporo rekrutacji na stanowiska juniorskie. Najczęściej powtarzaną przez rekrutów pożądaną …","keywords":["tests"],"articleBody":"Testy to święty gral początkujących programistów. Będąc na stanowisku CTO prowadziłem sporo rekrutacji na stanowiska juniorskie. Najczęściej powtarzaną przez rekrutów pożądaną cechą zespołu było praktykowanie pisania testów.\nPrzy okazji testów wszyscy wspominali o podejściu TDD (Test Driven Design), a nawet byli w stanie zdefiniować głównego założenie tego podejścia. Niestety ani jeden z nich nie pracował w takim podejściu, a zdecydowana większość z nich nigdy nawet nie pisała testów. Wszyscy narzekali, że w projektach, z którymi obecnie pracują testów nie ma i podawali to jako główną przyczynę problemów z aplikacją.\n The grass is always greener on the other side of the fence\n Wszyscy testujemy Pracując w jednej z firm miałem sporą styczność z prowadzoną przez tę firmę fundacją. Fundacja ta była założycielem akcji, która ma na celu pomoc dzieciom w gorszej sytuacji materialnej wejść w życie dorosłe poprzez wyrównywanie ich szans na rynku pracy IT. Prowadzone było sporo szkoleń dla dzieci w różnym wieku w zakresie programowania.\nPracując z początkującymi programistami zauważyłem, że każdy, nawet najbardziej początkujący programista testuje swój kod. Przecież praktycznie wszyscy zaczynają od tego słynnego Hello World!. Jest to nic innego jak sprawdzenie, czy nasza aplikacja poprawnie się uruchamia, oraz czy mechanizm renderowania tekstu działa. Klawisz F5 pozwala weryfikować poprawność wprowadzanych zmian do kodu i “uruchamianie naszego testu” od nowa.\nW większych aplikacjach również można zauważyć, że programiści bardzo często posługują się w trakcie pisania jednym zestawem poleceń. Są to wszelakiego rodzaju var_dump, var_export, dd, dump, die, exit czyli funkcje, które informują w jakim stanie znajduje się w danym czasie aplikacja.\nPo skończeniu pisania fragmentu kodu, aplikacji użycie tych funkcji zostaje usunięte i aplikacja jest już “gotowa”.\nA co gdyby te wszystkie procesy zautomatyzować… ?\nCo warto testować? To zależy. Od czego? Głównie od tego co piszemy. Czy piszemy stronę firmową? Czy piszemy system bankowy? Czy piszemy może oprogramowanie do marsjańskiego łazika? W każdym z tych przypadków nacisk na testowanie oprogramowania będzie inny.\nTesty można podzielić na 3 główne rodzaje. Testy end to end, integracyjne oraz jednostkowe. Zależności między nimi idealnie ilustruje poniższa grafika.\nTesty End to end są najbardziej czasochłonne sprawdzają największy obszar mechanizmów jednoczenie co powoduje że są bardzo kosztowne w utrzymaniu. Jedna zmiana może wymagać szeregu aktualizacji w kodzie testującym.\nTesty integracyjne dotykają jedynie wybranych elementów systemu.\nNajszybciej pisze się jednak testy jednostkowe. Koszt ich utrzymania jest również najniższy ponieważ jeden test może testować jedynie jedno zadanie.\nCzym jest test? Definicje testu można pewnie bardzo łatwo wywnioskować po początku tego tekstu.\nTest to kod, który testuje inny kod.\nMoże sprawdzać oczekiwany wynik. Może sprawdzać wystąpienie wyjątków.\nCzym jest jednostka Jednostka w rozumieniu testów jednostkowych to najmniejsza testowalna część kodu aplikacji.\nPo co w ogóle testować? Testy automatyczne są kodem. Kod można dowolną ilość razy uruchamiać. Jest jest to angażujące dla osoby obsługującej aplikację. Przy zastosowaniu CI jest praktycznie bezobsługowe. Lepiej oddać mozolną powtarzalną pracę komputerowi. Przenosząc tą odpowiedzialność na komputer nie tylko jesteśmy w stanie zaoszczędzony czas przeznaczyć na inne rzeczy, ale też komputer jest w stanie naszą pracę wykonać dużo, dużo szybciej. Projekt zawierający tysiące testów jednostkowych komputer jest w stanie przetestować nawet w minutę.\nCo więcej, jeżeli nasze testy są poprawnie napisane jesteśmy możemy być pewni, że testy wykonywane są za każdym razem w identyczny sposób. Przy testowaniu tego ręcznie człowiek może się wiele razy pomylić.\nJeżeli automat jest taki szybki to po co ograniczać się jedynie do testowania kodu nad, którym obecnie pracujemy. Automat może testować wszystkie funkcjonalności aplikacji. Przez co możemy spać spokojnie wiedząc, że nowo napisany kod nie zepsuje niczego po drugiej stronie aplikacji. Skutkuje to uniknięciem wielu niepotrzebnych poprawek, debugowaniu całej aplikacji i korzystaniu z opcji git blame aby znaleźć winowajcę.\nMyślę, że zdecydowana większość programistów nie lubi pisać dokumentacji do swojego kodu. Zwłaszcza, jeżeli jest ona potrzebna dla innych programistów. Posiadając testy danej funkcjonalności w pewnym sensie stają się one jej dokumentacją. W testach zawarte są wszystkie przypadki użycia interfejsów danej klasy. To jak można z niej korzystać, a jak nie. Testy zawsze są aktualnie ponieważ odzwierciedlają sam kod aplikacji. Nigdy wiec nie rozjadą się względem faktycznego stanu.\n","wordCount":"670","inLanguage":"en","datePublished":"2021-02-22T20:09:07+01:00","dateModified":"2021-02-22T20:09:07+01:00","author":[{"@type":"Person","name":"Piotr Musiał"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://piotrmus.github.io/blog/tests/"},"publisher":{"@type":"Organization","name":"Piotr Musiał","logo":{"@type":"ImageObject","url":"https://piotrmus.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://piotrmus.github.io/ accesskey=h title="Piotr Musiał (Alt + H)">Piotr Musiał</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://piotrmus.github.io/hi/ title="🖐 Cześć"><span>🖐 Cześć</span></a></li><li><a href=https://piotrmus.github.io/blog/ title="✍ Blog"><span>✍ Blog</span></a></li><li><a href=https://piotrmus.github.io/tags/ title="🏷 Tagi"><span>🏷 Tagi</span></a></li><li><a href=https://piotrmus.github.io/uses/ title="💻 Rzeczy"><span>💻 Rzeczy</span></a></li><li><a href=https://piotrmus.github.io/index.xml title="📖 RSS"><span>📖 RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Testy</h1><div class=post-meta>February 22, 2021&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Piotr Musiał</div></header><div class=post-content><p>Testy to święty gral początkujących programistów. Będąc na stanowisku CTO prowadziłem sporo rekrutacji na stanowiska
juniorskie. Najczęściej powtarzaną przez rekrutów pożądaną cechą zespołu było praktykowanie pisania testów.</p><p>Przy okazji testów wszyscy wspominali o podejściu TDD (Test Driven Design), a nawet byli w stanie zdefiniować głównego
założenie tego podejścia. Niestety ani jeden z nich nie pracował w takim podejściu, a zdecydowana większość z nich nigdy
nawet nie pisała testów. Wszyscy narzekali, że w projektach, z którymi obecnie pracują testów nie ma i podawali to jako
główną przyczynę problemów z aplikacją.</p><blockquote><p>The grass is always greener on the other side of the fence</p></blockquote><h3 id=wszyscy-testujemy>Wszyscy testujemy<a hidden class=anchor aria-hidden=true href=#wszyscy-testujemy>#</a></h3><p>Pracując w jednej z firm miałem sporą styczność z prowadzoną przez tę firmę fundacją. Fundacja ta była założycielem
akcji, która ma na celu pomoc dzieciom w gorszej sytuacji materialnej wejść w życie dorosłe poprzez wyrównywanie ich
szans na rynku pracy IT. Prowadzone było sporo szkoleń dla dzieci w różnym wieku w zakresie programowania.</p><p>Pracując z początkującymi programistami zauważyłem, że każdy, nawet najbardziej początkujący programista <strong>testuje</strong>
swój kod. Przecież praktycznie wszyscy zaczynają od tego słynnego <strong>Hello World!</strong>. Jest to nic innego jak sprawdzenie,
czy nasza aplikacja poprawnie się uruchamia, oraz czy mechanizm renderowania tekstu działa. Klawisz F5 pozwala
weryfikować poprawność wprowadzanych zmian do kodu i &ldquo;uruchamianie naszego testu&rdquo; od nowa.</p><p>W większych aplikacjach również można zauważyć, że programiści bardzo często posługują się w trakcie pisania jednym
zestawem poleceń. Są to wszelakiego rodzaju <code>var_dump</code>, <code>var_export</code>, <code>dd</code>, <code>dump</code>, <code>die</code>, <code>exit</code> czyli funkcje, które
informują w jakim stanie znajduje się w danym czasie aplikacja.</p><p>Po skończeniu pisania fragmentu kodu, aplikacji użycie tych funkcji zostaje usunięte i aplikacja jest już &ldquo;gotowa&rdquo;.</p><p>A co gdyby te wszystkie procesy zautomatyzować&mldr; ?</p><h3 id=co-warto-testować>Co warto testować?<a hidden class=anchor aria-hidden=true href=#co-warto-testować>#</a></h3><p>To zależy. Od czego? Głównie od tego co piszemy. Czy piszemy stronę firmową? Czy piszemy system bankowy? Czy piszemy
może oprogramowanie do marsjańskiego łazika? W każdym z tych przypadków nacisk na testowanie oprogramowania będzie inny.</p><p>Testy można podzielić na 3 główne rodzaje. Testy end to end, integracyjne oraz jednostkowe. Zależności między nimi
idealnie ilustruje poniższa grafika.</p><p><img src=/images/testy_piramida.png alt="Piramida testy"></p><p>Testy End to end są najbardziej czasochłonne sprawdzają największy obszar mechanizmów jednoczenie co powoduje że są
bardzo kosztowne w utrzymaniu. Jedna zmiana może wymagać szeregu aktualizacji w kodzie testującym.</p><p>Testy integracyjne dotykają jedynie wybranych elementów systemu.</p><p>Najszybciej pisze się jednak testy jednostkowe. Koszt ich utrzymania jest również najniższy ponieważ jeden test może
testować jedynie jedno zadanie.</p><h3 id=czym-jest-test>Czym jest test?<a hidden class=anchor aria-hidden=true href=#czym-jest-test>#</a></h3><p>Definicje testu można pewnie bardzo łatwo wywnioskować po początku tego tekstu.</p><p><strong>Test to kod, który testuje inny kod.</strong></p><p>Może sprawdzać oczekiwany wynik. Może sprawdzać wystąpienie wyjątków.</p><h3 id=czym-jest-jednostka>Czym jest jednostka<a hidden class=anchor aria-hidden=true href=#czym-jest-jednostka>#</a></h3><p>Jednostka w rozumieniu testów jednostkowych to najmniejsza testowalna część kodu aplikacji.</p><h3 id=po-co-w-ogóle-testować>Po co w ogóle testować?<a hidden class=anchor aria-hidden=true href=#po-co-w-ogóle-testować>#</a></h3><p>Testy automatyczne są kodem. Kod można dowolną ilość razy uruchamiać. Jest jest to angażujące dla osoby obsługującej
aplikację. Przy zastosowaniu CI jest praktycznie bezobsługowe. Lepiej oddać mozolną powtarzalną pracę komputerowi.
Przenosząc tą odpowiedzialność na komputer nie tylko jesteśmy w stanie zaoszczędzony czas przeznaczyć na inne rzeczy,
ale też komputer jest w stanie naszą pracę wykonać dużo, dużo szybciej. Projekt zawierający tysiące testów jednostkowych
komputer jest w stanie przetestować nawet w minutę.</p><p>Co więcej, jeżeli nasze testy są poprawnie napisane jesteśmy możemy być pewni, że testy wykonywane są za każdym razem w
identyczny sposób. Przy testowaniu tego ręcznie człowiek może się wiele razy pomylić.</p><p>Jeżeli automat jest taki szybki to po co ograniczać się jedynie do testowania kodu nad, którym obecnie pracujemy.
Automat może testować wszystkie funkcjonalności aplikacji. Przez co możemy spać spokojnie wiedząc, że nowo napisany kod
nie zepsuje niczego po drugiej stronie aplikacji. Skutkuje to uniknięciem wielu niepotrzebnych poprawek, debugowaniu
całej aplikacji i korzystaniu z opcji <code>git blame</code> aby znaleźć winowajcę.</p><p>Myślę, że zdecydowana większość programistów nie lubi pisać dokumentacji do swojego kodu. Zwłaszcza, jeżeli jest ona
potrzebna dla innych programistów. Posiadając testy danej funkcjonalności w pewnym sensie stają się one jej
dokumentacją. W testach zawarte są wszystkie przypadki użycia interfejsów danej klasy. To jak można z niej korzystać, a
jak nie. Testy zawsze są aktualnie ponieważ odzwierciedlają sam kod aplikacji. Nigdy wiec nie rozjadą się względem
faktycznego stanu.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://piotrmus.github.io/tags/tests/>tests</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://piotrmus.github.io/>Piotr Musiał</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>