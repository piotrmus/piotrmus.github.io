[{"content":"Testy to święty gral początkujących programistów. Będąc na stanowisku CTO prowadziłem sporo rekrutacji na stanowiska juniorskie. Najczęściej powtarzaną przez rekrutów pożądaną cechą zespołu było praktykowanie pisania testów.\nPrzy okazji testów wszyscy wspominali o podejściu TDD (Test Driven Design), a nawet byli w stanie zdefiniować głównego założenie tego podejścia. Niestety ani jeden z nich nie pracował w takim podejściu, a zdecydowana większość z nich nigdy nawet nie pisała testów. Wszyscy narzekali, że w projektach, z którymi obecnie pracują testów nie ma i podawali to jako główną przyczynę problemów z aplikacją.\n The grass is always greener on the other side of the fence\n Wszyscy testujemy Pracując w jednej z firm miałem sporą styczność z prowadzoną przez tę firmę fundacją. Fundacja ta była założycielem akcji, która ma na celu pomoc dzieciom w gorszej sytuacji materialnej wejść w życie dorosłe poprzez wyrównywanie ich szans na rynku pracy IT. Prowadzone było sporo szkoleń dla dzieci w różnym wieku w zakresie programowania.\nPracując z początkującymi programistami zauważyłem, że każdy, nawet najbardziej początkujący programista testuje swój kod. Przecież praktycznie wszyscy zaczynają od tego słynnego Hello World!. Jest to nic innego jak sprawdzenie, czy nasza aplikacja poprawnie się uruchamia, oraz czy mechanizm renderowania tekstu działa. Klawisz F5 pozwala weryfikować poprawność wprowadzanych zmian do kodu i \u0026ldquo;uruchamianie naszego testu\u0026rdquo; od nowa.\nW większych aplikacjach również można zauważyć, że programiści bardzo często posługują się w trakcie pisania jednym zestawem poleceń. Są to wszelakiego rodzaju var_dump, var_export, dd, dump, die, exit czyli funkcje, które informują w jakim stanie znajduje się w danym czasie aplikacja.\nPo skończeniu pisania fragmentu kodu, aplikacji użycie tych funkcji zostaje usunięte i aplikacja jest już \u0026ldquo;gotowa\u0026rdquo;.\nA co gdyby te wszystkie procesy zautomatyzować\u0026hellip; ?\nCo warto testować? To zależy. Od czego? Głównie od tego co piszemy. Czy piszemy stronę firmową? Czy piszemy system bankowy? Czy piszemy może oprogramowanie do marsjańskiego łazika? W każdym z tych przypadków nacisk na testowanie oprogramowania będzie inny.\nTesty można podzielić na 3 główne rodzaje. Testy end to end, integracyjne oraz jednostkowe. Zależności między nimi idealnie ilustruje poniższa grafika.\nTesty End to end są najbardziej czasochłonne sprawdzają największy obszar mechanizmów jednoczenie co powoduje że są bardzo kosztowne w utrzymaniu. Jedna zmiana może wymagać szeregu aktualizacji w kodzie testującym.\nTesty integracyjne dotykają jedynie wybranych elementów systemu.\nNajszybciej pisze się jednak testy jednostkowe. Koszt ich utrzymania jest również najniższy ponieważ jeden test może testować jedynie jedno zadanie.\nCzym jest test? Definicje testu można pewnie bardzo łatwo wywnioskować po początku tego tekstu.\nTest to kod, który testuje inny kod.\nMoże sprawdzać oczekiwany wynik. Może sprawdzać wystąpienie wyjątków.\nCzym jest jednostka Jednostka w rozumieniu testów jednostkowych to najmniejsza testowalna część kodu aplikacji.\nPo co w ogóle testować? Testy automatyczne są kodem. Kod można dowolną ilość razy uruchamiać. Jest jest to angażujące dla osoby obsługującej aplikację. Przy zastosowaniu CI jest praktycznie bezobsługowe. Lepiej oddać mozolną powtarzalną pracę komputerowi. Przenosząc tą odpowiedzialność na komputer nie tylko jesteśmy w stanie zaoszczędzony czas przeznaczyć na inne rzeczy, ale też komputer jest w stanie naszą pracę wykonać dużo, dużo szybciej. Projekt zawierający tysiące testów jednostkowych komputer jest w stanie przetestować nawet w minutę.\nCo więcej, jeżeli nasze testy są poprawnie napisane jesteśmy możemy być pewni, że testy wykonywane są za każdym razem w identyczny sposób. Przy testowaniu tego ręcznie człowiek może się wiele razy pomylić.\nJeżeli automat jest taki szybki to po co ograniczać się jedynie do testowania kodu nad, którym obecnie pracujemy. Automat może testować wszystkie funkcjonalności aplikacji. Przez co możemy spać spokojnie wiedząc, że nowo napisany kod nie zepsuje niczego po drugiej stronie aplikacji. Skutkuje to uniknięciem wielu niepotrzebnych poprawek, debugowaniu całej aplikacji i korzystaniu z opcji git blame aby znaleźć winowajcę.\nMyślę, że zdecydowana większość programistów nie lubi pisać dokumentacji do swojego kodu. Zwłaszcza, jeżeli jest ona potrzebna dla innych programistów. Posiadając testy danej funkcjonalności w pewnym sensie stają się one jej dokumentacją. W testach zawarte są wszystkie przypadki użycia interfejsów danej klasy. To jak można z niej korzystać, a jak nie. Testy zawsze są aktualnie ponieważ odzwierciedlają sam kod aplikacji. Nigdy wiec nie rozjadą się względem faktycznego stanu.\n","permalink":"https://piotrmus.github.io/blog/tests/","summary":"Testy to święty gral początkujących programistów. Będąc na stanowisku CTO prowadziłem sporo rekrutacji na stanowiska juniorskie. Najczęściej powtarzaną przez rekrutów pożądaną cechą zespołu było praktykowanie pisania testów.\nPrzy okazji testów wszyscy wspominali o podejściu TDD (Test Driven Design), a nawet byli w stanie zdefiniować głównego założenie tego podejścia. Niestety ani jeden z nich nie pracował w takim podejściu, a zdecydowana większość z nich nigdy nawet nie pisała testów. Wszyscy narzekali, że w projektach, z którymi obecnie pracują testów nie ma i podawali to jako główną przyczynę problemów z aplikacją.","title":"Testy"},{"content":"Cześć! Jestem Piotr Musiał. Jestem programistą z 11-letnim doświadczeniem. Jestem pasjonatem programowania, architektem oprogramowania skupiającym się na fajnym projektach w nowych technologiach. Silnie uzależniony od podejścia Domain Driven Design.\n","permalink":"https://piotrmus.github.io/hi/","summary":"Cześć! Jestem Piotr Musiał. Jestem programistą z 11-letnim doświadczeniem. Jestem pasjonatem programowania, architektem oprogramowania skupiającym się na fajnym projektach w nowych technologiach. Silnie uzależniony od podejścia Domain Driven Design.","title":"Hello world!"},{"content":"Lista rzeczy, które pomagają mi w codziennej pracy.\nHardware  Dell XPS 15 Laptop Steelseries Apex RAW Klawiatura Mysz A4Tech Bloody V8 Mysz Bose QuietComfort 25 Słuchawki Samsung Galaxy S10e Telefon 2x Dell U2518D Monitory  PC  SilentiumPC Grandis XE1236 Chłodzenie CPU MSI Z97 GAMING 3 Płyta główna HyperX Savage, 32 GB Pamięć RAM Gigabyte GeForce GTX 970 Karta graficzna Western Digital Red 2TB Dysk HDD GoodRam CX300 240GB Dysk SSD be quiet! Pure Power BQT L8-CM-630W Zasilacz SilentiumPC Gladius X60 Pure Black Obudowa  Software  Ubuntu 20.04 System operacyjny PHPStorm IDE Vim Edytor terminalowy Todoist Manager zadań Feedly Czytnik RSS  Smart Home  Raspberry Pi 3B Sprzęt CC2531 Bramka Zigbee Xiaomi Mi Smart Sensor Set Czujniki Xiaomi Air purifier 2S Oczyszczasz powietrza Yeelight LED Smart Bulb RGB Żarówka Xiaomi Mi LED Desk Lamp Lampka na biurko Chromecast 2020 Google TV Media stick Chromecast 3 Media stick  Books  Atomowe nawyki Domain-driven design Clean code PHP by example  ","permalink":"https://piotrmus.github.io/uses/","summary":"Lista rzeczy, które pomagają mi w codziennej pracy.\nHardware  Dell XPS 15 Laptop Steelseries Apex RAW Klawiatura Mysz A4Tech Bloody V8 Mysz Bose QuietComfort 25 Słuchawki Samsung Galaxy S10e Telefon 2x Dell U2518D Monitory  PC  SilentiumPC Grandis XE1236 Chłodzenie CPU MSI Z97 GAMING 3 Płyta główna HyperX Savage, 32 GB Pamięć RAM Gigabyte GeForce GTX 970 Karta graficzna Western Digital Red 2TB Dysk HDD GoodRam CX300 240GB Dysk SSD be quiet!","title":"Piotr korzysta..."}]